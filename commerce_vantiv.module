<?php
/**
 * @file
 * Implements Litle payment services for use in Drupal Commerce.
 */
define('COMMERCE_VANTIV_STATUS_CAPTURE', 'CAPTURE');
define('COMMERCE_VANTIV_STATUS_CAPTURED', 'CAPTURED');
define('COMMERCE_VANTIV_STATUS_REFUND', 'REFUND');
define('COMMERCE_VANTIV_STATUS_REFUNDED', 'REFUNDED');
define('COMMERCE_VANTIV_STATUS_VOID', 'VOIDED');
define('COMMERCE_VANTIV_STATUS_VOIDED', 'VOIDEDED');

/**
 * Implements hook_libraries_info().
 */
function commerce_vantiv_libraries_info() {
  $libraries['litle'] = array(
    'name' => 'Litle',
    'vendor url' => 'http://www.vantiv.com/',
    'download url' => 'https://github.com/LitleCo/litle-sdk-for-php/archive/master.zip',
    'path' => 'litle',
    'files' => array(
      'php' => array(
        //'sdk/Setup.php',
        'sdk/XmlFields.php',
        'sdk/XmlParser.php',
        'sdk/UrlMapper.php',
        'sdk/LitleXmlMapper.php',
        'sdk/Obj2xml.php',
        'sdk/Checker.php',
        'sdk/Transactions.php',
        'sdk/LitleOnline.php',
        'sdk/LitleOnlineRequest.php',
        'sdk/Communication.php',
        'sdk/BatchRequest.php',
        'sdk/LitleRequest.php',
        'sdk/LitleResponseProcessor.php',
      ),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_vantiv_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['vantiv_direct'] = array(
    'base' => 'commerce_vantiv',
    'title' => t('Vantiv direcet payment'),
    'short_title' => t('Vantiv direcet payment'),
    'display_title' => t('Vantiv direcet payment'),
    'description' => t('Vantiv direcet payment'),
    'terminal' => FALSE,
    'offsite' => FALSE,
    'offsite_autoredirect' => FALSE,
    'active' => FALSE,
    'callback' => array(),
    'file' => 'includes/commerce_vantiv_direct.inc',
    'cardonfile' => array(
      'charge callback' => 'commerce_vantiv_cardonfile_charge',
      'update callback' => 'commerce_vantiv_cardonfile_update',
      'delete callback' => 'commerce_vantiv_cardonfile_delete',
      'create callback' => 'commerce_vantiv_cardonfile_create',
    ),
  );

  return $payment_methods;
}

/**
 * Charges card on file with given amount.
 */
function commerce_vantiv_cardonfile_charge($payment_method, $card_data, $order, $charge = NULL) {
  $api = commerce_vantiv_api_object();
  $customer_profile = commerce_customer_profile_load($order->commerce_customer_billing['und'][0]['profile_id']);

  if (is_object($charge) == TRUE) {
    $amount = new stdClass();
    $amount->amount = $charge->amount;
    $amount->currency_code = $charge->currency_code;
  }
  elseif (is_array($charge) == TRUE) {
    $amount = new stdClass();
    $amount->amount = $charge['amount'];
    $amount->currency_code = $charge['currency_code'];
  }
  else {
    $amount = '';
  }

  if (is_object($card_data) == TRUE) {
    foreach($card_data as $k => $v) {
      $card_array[$k] = $v;
    }
    variable_set('card_data', $card_array);
  }
  else {
    variable_set('card_data', $card_data);
  }

  $result = $api->directPayments($customer_profile, $order, $card_data, $payment_method, $amount, $card_data->remote_id);
  return TRUE;
}

/**
 * Updates card on file.
 */
function commerce_vantiv_cardonfile_update() {
  global $user;
  if (!empty($_POST)) {
    $params = $_POST;
  }
  else {
    $params = $_GET;
  }
  $card = commerce_cardonfile_load($params['hidden_cardid']);
  if (is_array($card) == TRUE) {
    $card = reset($card);
  }

  $token = $card->remote_id;
  // Create initial transaction.
  $api = commerce_vantiv_api_object();
  $api->libraryLoad();
  $data = array(
    'user' => $api->user,
    'password' => $api->password,
    'merchantId' => $api->merchant_id,
    'reportGroup' => 'rtpGrp',
    'url' => $api->accountLinks($api->account),
    'litle_requests_path' => $api->accountLinks($api->account),
    'batch_requests_path' => '',
    'proxy' => '',
    'sftp_username' => '',
    'sftp_password' => '',
    'batch_url' => '',
    'tcp_port' => '',
    'tcp_ssl' => '',
    'tcp_timeout' => '',
    'print_xml' => '',
    // Fake order.
    'orderId' => $user->uid . '-' . time(),
    'orderSource'=>'ecommerce',
    'amount' => 10,
    'accountNumber' => $params['credit_card']['number'],
    'card' => array(
      'number' => $params['credit_card']['number'],
  	  'expDate' => $params['credit_card']['exp_month'] . substr($params['credit_card']['exp_year'], 2, 4),
  	  'cardValidationNum' => $params['code'],
  		'type' => $api->cardTypes($params['credit_card']['type']),
    ),
   /* 'token' => array(
      'litleToken' => $token,
    ),*/
  );

  $initilaize = new litle\sdk\LitleOnlineRequest();
  $response = $initilaize->saleRequest($data);
  $payload = litle\sdk\XmlParser::getDomDocumentAsString($response);
  variable_set('update_card', $payload);
  // $result = $api->directPayments($customer_profile, $order, $card_data, $payment_method, $amount, $card_data->remote_id);

  // Get response information.
  $response_code = litle\sdk\XmlParser::getNode($response,'response');
  $order_id = litle\sdk\XmlParser::getNode($response,'orderId');
  $response_time = litle\sdk\XmlParser::getNode($response,'responseTime');
  $message = litle\sdk\XmlParser::getNode($response,'message');
  $auth_code = litle\sdk\XmlParser::getNode($response,'authCode');
  $avs_result = litle\sdk\XmlParser::getNode($response,'avsResult');
  $card_validation_result = litle\sdk\XmlParser::getNode($response,'cardValidationResult');
  $litle_txn_id = litle\sdk\XmlParser::getNode($response,'litleTxnId');

  $saleResponse = litle\sdk\XmlParser::getNode($response, 'saleResponse');
  $accountUpdater = litle\sdk\XmlParser::getNode($response, 'accountUpdater');
  $newCardInfo = litle\sdk\XmlParser::getNode($response, 'newCardInfo');
  $type = litle\sdk\XmlParser::getNode($response, 'type');
  $number = litle\sdk\XmlParser::getNode($response, 'number');
  $expDate = litle\sdk\XmlParser::getNode($response, 'expDate');

  if (!empty($accountUpdater) and !empty($newCardInfo)) {
    $card_type = $api->cardTypes('', $type);
    $exp_month = substr($expDate, 1, 2);
    $exp_year = substr($expDate, -2, 2);
    $card->card_name = $params['credit_card']['owner'];
    $card->card_number = substr($number, -4, 4);
    $card->type = !empty($card_type) ? $card_type : '';
    $card->card_exp_month = $exp_month;
    $card->card_exp_year = $exp_year;
    commerce_cardonfile_save($card);
    return $card;
  }

  return TRUE;
}

/**
 * Deletes card on file.
 */
function commerce_vantiv_cardonfile_delete() {
  return TRUE;
}

/**
 * Creates card on file.
 */
function commerce_vantiv_cardonfile_create() {
  global $user;
  if (!empty($_POST)) {
    $params = $_POST;
  }
  else {
    $params = $_GET;
  }

  $api = commerce_vantiv_api_object();
  $api->libraryLoad();

  $data = array(
    'user' => $api->user,
    'password' => $api->password,
    'merchantId' => $api->merchant_id,
    'reportGroup' => 'rtpGrp',
    'url' => $api->accountLinks($api->account),
    'litle_requests_path' => $api->accountLinks($api->account),
    'batch_requests_path' => '',
    'proxy' => '',
    'sftp_username' => '',
    'sftp_password' => '',
    'batch_url' => '',
    'tcp_port' => '',
    'tcp_ssl' => '',
    'tcp_timeout' => '',
    'print_xml' => '',
    'orderId' => $user->uid . '-' . time(),
    'accountNumber' => $params['credit_card']['number'],
    'card' => array(
      'number' => $params['credit_card']['number'],
  	  'expDate' => $params['credit_card']['exp_month'] . substr($params['credit_card']['exp_year'], 2, 4),
  	  'cardValidationNum' => $params['credit_card']['code'],
  		'type' => $api->cardTypes($params['credit_card']['type']),
    ),
  );

  $initilaize = new litle\sdk\LitleOnlineRequest();
  $response = $initilaize->registerTokenRequest($data);
  $payload = litle\sdk\XmlParser::getDomDocumentAsString($response);
  variable_set('cof_payload_add', $payload);

  $response_code = litle\sdk\XmlParser::getNode($response,'response');
  $order_id = litle\sdk\XmlParser::getNode($response,'orderId');
  $response_time = litle\sdk\XmlParser::getNode($response,'responseTime');
  $message = litle\sdk\XmlParser::getNode($response,'message');
  $auth_code = litle\sdk\XmlParser::getNode($response,'authCode');
  $avs_result = litle\sdk\XmlParser::getNode($response,'avsResult');
  $card_validation_result = litle\sdk\XmlParser::getNode($response,'cardValidationResult');
  $litle_txn_id = litle\sdk\XmlParser::getNode($response,'litleTxnId');
  $litleToken = litle\sdk\XmlParser::getNode($response,'litleToken');

  //$customer_profile = commerce_customer_profile_load($order->commerce_customer_billing['und'][0]['profile_id']);
  $card_data = commerce_cardonfile_new();
  $card_data->uid = $user->uid;
  $card_data->remote_id = $litleToken;
  $card_data->payment_method = 'vantiv_direct';
  $card_data->instance_id = 'vantiv_direct|commerce_payment_vantiv_direct';
  $card_data->card_type = $params['credit_card']['type'];
  $card_data->card_name = $params['credit_card']['owner'];
  $card_data->card_number = drupal_substr($params['credit_card']['number'], -4);
  $card_data->card_exp_month = $params['credit_card']['exp_month'];
  $card_data->card_exp_year = $params['credit_card']['exp_year'];
  $card_data->status = 1;
  commerce_cardonfile_save($card_data);
  return $card_data;
}

/**
 * Implements hook_menu().
 */
function commerce_vantiv_menu() {
  $items = array();

  // Add a menu item for capture.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/vantiv_capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_vantiv_capture_form', 3, 5),
    'access callback' => 'commerce_vantiv_capture_access',
    'access arguments' => array(3, 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/commerce_vantiv.admin.inc',
    'weight' => 1,
  );

  // Add a menu item for refund.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/vantiv_refund'] = array(
    'title' => 'Refund',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_vantiv_refund_form', 3, 5),
    'access callback' => 'commerce_vantiv_refund_access',
    'access arguments' => array(3, 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/commerce_vantiv.admin.inc',
    'weight' => 1,
  );

  // Add a menu item for void.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/vantiv_void'] = array(
    'title' => 'Void',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_vantiv_void_form', 3, 5),
    'access callback' => 'commerce_vantiv_void_access',
    'access arguments' => array(3, 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/commerce_vantiv.admin.inc',
    'weight' => 1,
  );

  return $items;
}

/**
 * Determine whether the user has permissions to perform capture.
 */
function commerce_vantiv_capture_access($order, $transaction) {
  // Return FALSE if the transaction isn't for Vantiv or isn't
  // awaiting capture.
  if (($transaction->payment_method !== 'vantiv_direct') || empty($transaction->remote_id) || $transaction->status !== COMMERCE_PAYMENT_STATUS_PENDING) {
    return FALSE;
  }
  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determine whether the user has permissions to perform capture.
 */
function commerce_vantiv_refund_access($order, $transaction) {
  // Return FALSE if the transaction isn't for Vantiv or isn't
  // awaiting refund.
  if (($transaction->payment_method !== 'vantiv_direct') || empty($transaction->remote_id) || ($transaction->status !== COMMERCE_VANTIV_STATUS_CAPTURE && $transaction->status !== COMMERCE_PAYMENT_STATUS_SUCCESS)) {
    return FALSE;
  }
  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determine whether the user has permissions to perform capture.
 */
function commerce_vantiv_void_access($order, $transaction) {
  // Return FALSE if the transaction isn't for Vantiv or isn't
  // awaiting refund.
  if (($transaction->payment_method !== 'vantiv_direct') || empty($transaction->remote_id) || ($transaction->status !== COMMERCE_VANTIV_STATUS_CAPTURE && $transaction->status !== COMMERCE_PAYMENT_STATUS_SUCCESS)) {
    return FALSE;
  }
  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Settings form in the admin UI for the payment method.
 */
function commerce_vantiv_settings_form($settings = NULL) {
  $settings = (array) $settings + array(
    'account' => 'test',
    'pspid' => '',
    'currency' => variable_get('commerce_default_currency', 'USD'),
    'language' => '',
    'sha_in' => '',
    'sha_out' => '',
    'language_list' => array(),
  );

  $form['account'] = array(
    '#type' => 'radios',
    '#title' => t('Processing url'),
    '#description' => t('Please choose Litle url from the following list:'),
    '#options' => array(
      'sandbox' => ('Sandbox test link - for testing purposes only'),
      'postlive' => ('Postlive link'),
      'transact_postlive' => ('Transact Postlive'),
      'production' => ('Production link'),
      'production_transact' => ('Production Transactions'),
      'prelive' => ('Prelive'),
      'transact_prelive' => ('Transact Prelive'),
    ),
    '#default_value' => isset($settings['account']) ? $settings['account'] : 'sandbox',
    '#required' => TRUE,
  );

  $form['user'] = array(
    '#type' => 'textfield',
    '#title' => t('USER ID'),
    '#description' => t('Enter your API username.'),
    '#default_value' => !empty($settings['user']) ? $settings['user'] : '',
    '#required' => TRUE,
  );

  $form['merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant ID'),
    '#description' => t('Enter your merchant id.'),
    '#default_value' => !empty($settings['merchant_id']) ? $settings['merchant_id'] : '',
    '#required' => TRUE,
  );

  $form['password'] = array(
    '#type' => 'textfield',
    '#title' => t('Password'),
    '#description' => t('Your API password.'),
    '#default_value' => !empty($settings['password']) ? $settings['password'] : '',
    '#required' => TRUE,
  );

  $form['3d_secure'] = array(
    '#type' => 'radios',
    '#title' => t('3D Secure security check of customers cards.'),
    '#default_value' => !empty($settings['3d_secure']) ? $settings['3d_secure'] : '0',
    '#options' => array(
      '0' => t('Allways require authentication.'),
      '1' => t('Do not perform 3D-Secure checks and always authorise.'),
    ),
  );

  $form['transaction_type_process'] = array(
    '#type' => 'radios',
    '#title' => t('Transaction type'),
    '#default_value' => empty($settings['transaction_type_process']) ? 'sale' : $settings['transaction_type_process'],
    '#options' => array(
      'sale' => t('Sale'),
      'pre_auth' => t('Pre-auth'),
    ),
  );

  $form['logs'] = array(
    '#type' => 'select',
    '#title' => t('Log issue responses.'),
    '#description' => t('Select whether or not the responses from the http requests should be logged.'),
    '#options' => array(
      '0' => t('Always log the responses'),
      '1' => t('Never log the responses'),
    ),
  );

  //$form['#submit'][] = 'commerce_vantiv_settings_form_submit';

  return $form;
}

/**
 * Loads the last saved transaction.
 */
function commerce_vantiv_load_last_saved_transaction() {
  global $user;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_payment_transaction')
  ->propertyCondition('uid', $user->uid);
  $query->propertyOrderBy('created', 'DESC');
  $query->range(0, 1);
  $return = array();
  $result = $query->execute();
    if (!empty($result['commerce_payment_transaction'])) {
    foreach ($result['commerce_payment_transaction'] as $transaction) {
      $return[] = entity_load_single('commerce_payment_transaction', $transaction->transaction_id);
    }
  }
  return $return;
}

/**
 * Creates api object.
 */
function commerce_vantiv_api_object($settings = array(), $instance_id = '') {
  $include_module = module_load_include('inc', 'commerce_vantiv', 'includes/commerce_vantiv.api');
  if (empty($instance_id)) {
    $instance = commerce_payment_method_instance_load('vantiv_direct|commerce_payment_vantiv_direct');
  }
  else {
    $instance = commerce_payment_method_instance_load($instance_id);
  }
  return new VantivApi($instance['settings']);
}

/**
 * Implements hool_commerce_payment_transaction_status_info().
 */
function commerce_vantiv_commerce_payment_transaction_status_info() {
  $statuses = array();

  $statuses[COMMERCE_VANTIV_STATUS_CAPTURE] = array(
    'status' => COMMERCE_VANTIV_STATUS_CAPTURE,
    'title' => t('Capture'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => TRUE,
  );

  $statuses[COMMERCE_VANTIV_STATUS_CAPTURED] = array(
    'status' => COMMERCE_VANTIV_STATUS_CAPTURED,
    'title' => t('Captured'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => TRUE,
  );

  $statuses[COMMERCE_VANTIV_STATUS_REFUND] = array(
    'status' => COMMERCE_VANTIV_STATUS_REFUND,
    'title' => t('Refund'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_VANTIV_STATUS_REFUNDED] = array(
    'status' => COMMERCE_VANTIV_STATUS_REFUNDED,
    'title' => t('Refunded'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_VANTIV_STATUS_VOID] = array(
    'status' => COMMERCE_VANTIV_STATUS_VOID,
    'title' => t('Void'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-failure.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_VANTIV_STATUS_VOIDED] = array(
    'status' => COMMERCE_VANTIV_STATUS_VOIDED,
    'title' => t('Voided'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-failure.png',
    'total' => FALSE,
  );

  return $statuses;
}
